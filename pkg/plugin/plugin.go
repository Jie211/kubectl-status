//go:generate statik -src templates/
package plugin

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"time"
	_ "unsafe" // required for using go:linkname in the file

	"github.com/Masterminds/sprig/v3"
	"github.com/dustin/go-humanize"
	"github.com/fatih/color"
	"github.com/pkg/errors"
	"github.com/pmezard/go-difflib/difflib"
	sfs "github.com/rakyll/statik/fs"
	"github.com/spf13/cast"
	"github.com/spf13/cobra"
	v1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/api/extensions/v1beta1"
	resource2 "k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/fields"
	"k8s.io/apimachinery/pkg/runtime"
	utilerrors "k8s.io/apimachinery/pkg/util/errors"
	"k8s.io/cli-runtime/pkg/resource"
	"k8s.io/client-go/kubernetes"
	appsv1 "k8s.io/client-go/kubernetes/typed/apps/v1"
	_ "k8s.io/client-go/plugin/pkg/client/auth" // Initialize all known client auth plugins.
	cmdutil "k8s.io/kubectl/pkg/cmd/util"
	"k8s.io/kubectl/pkg/scheme"
	metricsv "k8s.io/metrics/pkg/client/clientset/versioned"
	kyaml "sigs.k8s.io/yaml"

	_ "github.com/bergerx/kubectl-status/pkg/plugin/statik" // generated by statik
)

type IngressBackendIssue struct {
	IssueType string
	Backend   v1beta1.IngressBackend
}

var durationRound = (sprig.GenericFuncMap()["durationRound"]).(func(duration interface{}) string)

var funcMap = template.FuncMap{
	"green":                    color.GreenString,
	"yellow":                   color.YellowString,
	"red":                      color.RedString,
	"cyan":                     color.CyanString,
	"bold":                     color.New(color.Bold).SprintfFunc(),
	"colorAgo":                 colorAgo,
	"colorDuration":            colorDuration,
	"colorBool":                colorBool,
	"colorKeyword":             colorKeyword,
	"colorExitCode":            colorExitCode,
	"markRed":                  markRed,
	"markYellow":               markYellow,
	"markGreen":                markGreen,
	"redIf":                    redIf,
	"redBoldIf":                redBoldIf,
	"signalName":               signalName,
	"isPodConditionHealthy":    isPodConditionHealthy,
	"quantityToFloat64":        quantityToFloat64,
	"quantityToInt64":          quantityToInt64,
	"percent":                  percent,
	"colorPercent":             colorPercent,
	"humanizeSI":               humanizeSI,
	"getItemInList":            getItemInList,
	"getPodInNodeStatsSummary": getPodInNodeStatsSummary,
	"addFloat64":               addFloat64,
	"subFloat64":               subFloat64,
	"divFloat64":               divFloat64,
	"include":                  func(string, interface{}) string { return "not implemented" },
}

func addFloat64(i ...interface{}) float64 {
	var a float64 = 0
	for _, b := range i {
		a += cast.ToFloat64(b)
	}
	return a
}

func subFloat64(a, b float64) float64 {
	return b - a
}

func divFloat64(a, b float64) float64 {
	return b / a
}

func humanizeSI(unit string, input float64) string {
	return strings.Replace(humanize.SIWithDigits(input, 1, unit), " ", "", -1)
}

func quantityToFloat64(str string) float64 {
	quantity, _ := resource2.ParseQuantity(str)
	return float64(quantity.MilliValue()) / 1000
}

func quantityToInt64(str string) int64 {
	quantity, _ := resource2.ParseQuantity(str)
	return quantity.Value()
}

func percent(x, y float64) float64 {
	return x / y * 100
}

func colorPercent(format string, percent float64) string {
	str := fmt.Sprintf(format, percent)
	switch {
	case percent >= 100:
		return color.New(color.Bold, color.FgRed).Sprint(str)
	case percent >= 90:
		return color.RedString(str)
	case percent >= 80:
		return color.YellowString(str)
	}
	return str
}

func colorBool(cond bool, str string) string {
	if cond {
		return color.GreenString(str)
	} else {
		return color.New(color.FgRed, color.Bold).Sprintf(str)
	}
}

func getItemInList(list []interface{}, itemKey, itemValue string) map[string]interface{} {
	var item map[string]interface{}
	for _, untypedItem := range list {
		typedItem := untypedItem.(map[string]interface{})
		if typedItem[itemKey].(string) == itemValue {
			item = typedItem
			break
		}
	}
	return item
}

func getPodInNodeStatsSummary(namespace, name string, nodeStatsSummary []interface{}) map[string]interface{} {
	var item map[string]interface{}
	for _, untypedItem := range nodeStatsSummary {
		typedItem := untypedItem.(map[string]interface{})
		podRef := typedItem["podRef"].(map[string]interface{})
		if podRef["namespace"].(string) == namespace && podRef["name"].(string) == name {
			scheme.Scheme.Convert(&typedItem, &item, nil)
			break
		}
	}
	return item
}

func isPodConditionHealthy(condition map[string]interface{}) bool {
	switch {
	/*
		From https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties:

		> Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates
		> when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called
		> "Invalid".

		But apparently this is not common among most resources, so we have the list of cases that matches the expected
		behaviour rather than the exceptions.
	*/
	case strings.HasSuffix(fmt.Sprint(condition["type"]), "Pressure"), // Node Pressure conditions
		strings.HasSuffix(fmt.Sprint(condition["type"]), "Unavailable"), // Node NetworkUnavailable condition
		strings.HasSuffix(fmt.Sprint(condition["type"]), "Failure"),     // ReplicaSet ReplicaFailure: condition
		strings.HasPrefix(fmt.Sprint(condition["type"]), "Non"),         // CRD NonStructuralSchema condition
		condition["type"] == "Failed":                                   // Failed Jobs has this condition
		switch condition["status"] {
		case "False":
			return true
		case "True", "Unknown":
			return false
		default:
			// not likely to ever happen, but just in case
			return false
		}
	default:
		switch condition["status"] {
		case "True":
			return true
		case "False", "Unknown":
			return false
		default:
			return false
		}
	}
}

//go:linkname signame runtime.signame
func signame(sig uint32) string

func signalName(signal int64) string {
	return signame(uint32(signal))
}

func redIf(cond bool, str string) string {
	if cond {
		return color.RedString(str)
	}
	return str
}

func redBoldIf(cond bool, str string) string {
	if cond {
		return color.New(color.FgRed, color.Bold).Sprintf(str)
	}
	return str
}

func markRed(regex, s string) string {
	return markWithColor(regex, s, color.RedString)
}

func markYellow(regex, s string) string {
	return markWithColor(regex, s, color.YellowString)
}

func markGreen(regex, s string) string {
	return markWithColor(regex, s, color.GreenString)
}

func markWithColor(regex string, s string, colorStringFunc func(format string, a ...interface{}) string) string {
	re := regexp.MustCompile(regex)
	var result []string
	for _, line := range strings.Split(s, "\n") {
		for _, match := range re.FindAllString(line, -1) {
			line = strings.Replace(line, match, colorStringFunc(match), 1)
		}
		result = append(result, line)
	}
	return strings.Join(result, "\n")
}

func colorExitCode(exitCode int) string {
	switch exitCode {
	case 0:
		return strconv.Itoa(exitCode)
	default:
		return color.RedString("%d", exitCode)
	}
}

func colorKeyword(phase string) string {
	/* covers ".status.phase", ".status.state", ".status.reason", pod QOS,
		   for various types, e.g. pod, pv, pvc, svc, ns, etc ...

		Here a generic method is used since this can be used to cover unknown CRDs that follows conventions as well.
		This also helps with maintaining the list
	    E.g.:
	    * acme.cert-manager.io/v1alpha2 Order: .status.state: valid
	    * pvc: .status.phase Bound
	*/
	switch phase {
	case "Running", "Succeeded", "Active", "Available", "Bound", "valid", "Guaranteed", "Completed":
		return color.GreenString(phase)
	case "Pending", "Released", "Burstable":
		return color.YellowString(phase)
	case "Failed", "Unknown", "Terminating", "Evicted", "BestEffort", "OOMKilled", "ContainerCannotRun", "Error":
		return color.New(color.FgRed, color.Bold).Sprintf(phase)
	default:
		return phase
	}
}

func colorAgo(kubeDate string) string {
	t, _ := time.ParseInLocation("2006-01-02T15:04:05Z", kubeDate, time.UTC)
	duration := time.Since(t).Round(time.Second)
	return colorDuration(duration)
}

func ago(t time.Time) string {
	duration := time.Since(t).Round(time.Second)
	return durationRound(duration.String())
}

func colorDuration(duration time.Duration) string {
	str := durationRound(duration.String())
	if duration < time.Minute*5 {
		return color.RedString(str)
	}
	if duration < time.Hour {
		return color.YellowString(str)
	}
	if duration < time.Hour*24 {
		return color.MagentaString(str)
	}
	return str
}

func RunPlugin(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
	//log := logger.NewLogger()
	//log.Info(strings.Join(args, ","))
	clientSet, _ := f.KubernetesClientSet()
	clientConfig := f.ToRawKubeConfigLoader()
	allNamespaces := cmdutil.GetFlagBool(cmd, "all-namespaces")
	namespace, enforceNamespace, err := clientConfig.Namespace()
	if err != nil {
		return errors.WithMessage(err, "Failed getting namespace")
	}
	filenames := cmdutil.GetFlagStringSlice(cmd, "filename")
	isTest := cmdutil.GetFlagBool(cmd, "test")
	if isTest {
		if len(filenames) != 1 {
			return errors.New("when using --test, exactly one --filename must be provided")
		}
		filename := filenames[0]
		out, err := renderFile(filename)
		if err != nil {
			return err
		}
		fmt.Println(out)
		return nil
	}

	r := f.NewBuilder().
		Unstructured().
		NamespaceParam(namespace).DefaultNamespace().AllNamespaces(allNamespaces).
		FilenameParam(enforceNamespace, &resource.FilenameOptions{Filenames: filenames}).
		LabelSelectorParam(cmdutil.GetFlagString(cmd, "selector")).
		FieldSelectorParam(cmdutil.GetFlagString(cmd, "field-selector")).
		ResourceTypeOrNameArgs(true, args...).
		ContinueOnError().
		Latest().
		Flatten().
		Do()

	err = r.Err()
	if err != nil {
		return errors.WithMessage(err, "Failed during querying of resources")
	}

	var allErrs []error
	infos, err := r.Infos()
	if err != nil {
		allErrs = append(allErrs, err)
	}
	if len(infos) == 0 {
		if !allNamespaces && namespace != "" {
			fmt.Printf("No resources found in %s namespace\n", namespace)
		} else {
			fmt.Printf("No resources found.\n")
		}
	}
	for _, info := range infos {
		var err error
		obj := info.Object
		objKind := info.ResourceMapping().GroupVersionKind.Kind
		out, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&obj)
		if err != nil {
			allErrs = append(allErrs, err)
			continue
		}
		err = includeEvents(obj, clientSet, out)
		if err != nil {
			allErrs = append(allErrs, err)
			continue
		}
		kindInjectFuncMap := map[string][]func(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error{
			"Node":        {includeNodeMetrics, includeNodeLease, includePodDetailsOnNode, includeNodeStatsSummary},
			"Pod":         {includePodMetrics}, // kubectl get --raw /api/v1/nodes/minikube/proxy/stats/summary --> .pods[] | select podRef | containers[] | select name
			"Service":     {includeEndpoint},
			"StatefulSet": {includeStatefulSetDiff},
			"Ingress":     {includeIngressServices},
		}
		for kind, funcs := range kindInjectFuncMap {
			if objKind == kind {
				for _, fu := range funcs {
					err = fu(obj, f, out)
					if err != nil {
						allErrs = append(allErrs, err)
						continue
					}
				}
				if objKind == "Node" {
					x, _ := json.Marshal(out)
					y, _ := kyaml.JSONToYAML(x)
					_ = y
					//fmt.Println(string(y))
				}
			}
		}

		err = renderTemplateForMap(os.Stdout, out)
		if err != nil {
			allErrs = append(allErrs, err)
			continue
		}
		// Add a newline at the end of every template
		fmt.Println("")
	}
	return utilerrors.NewAggregate(allErrs)
}

func renderFile(manifestFilename string) (string, error) {
	var out map[string]interface{}
	manifestFile, _ := ioutil.ReadFile(manifestFilename)
	err := kyaml.Unmarshal(manifestFile, &out)
	if err != nil {
		return "", errors.WithMessage(err, "Failed getting JSON for object")
	}
	var output bytes.Buffer
	err = renderTemplateForMap(&output, out)
	if err != nil {
		return "", err
	}
	return output.String(), nil
}

func renderTemplateForMap(wr io.Writer, v map[string]interface{}) error {
	tmpl, err := getParsedTemplates()
	if err != nil {
		return err
	}
	kindTemplateName := findTemplateName(tmpl, v)
	return tmpl.ExecuteTemplate(wr, kindTemplateName, v)
}

func getParsedTemplates() (*template.Template, error) {
	templateText, err := getTemplate()
	if err != nil {
		return nil, err
	}
	funcMap := getFuncMap()
	tmpl, err := template.
		New("templates.tmpl").
		Funcs(funcMap).
		Parse(templateText)
	if err != nil {
		return nil, err
	}
	funcMap["include"] = include
	tmpl.Funcs(funcMap)
	return tmpl, nil
}

func getFuncMap() template.FuncMap {
	f := sprig.TxtFuncMap()
	for k, v := range funcMap {
		f[k] = v
	}
	return f
}

func include(name string, data interface{}) (string, error) {
	var buf strings.Builder
	tmpl, err := getParsedTemplates()
	if err != nil {
		return "", err
	}
	funcMap := getFuncMap()
	funcMap["include"] = include
	tmpl.Funcs(funcMap)
	err = tmpl.ExecuteTemplate(&buf, name, data)
	return buf.String(), err
}

func findTemplateName(tmpl *template.Template, v map[string]interface{}) string {
	objKind := v["kind"].(string)
	var kindTemplateName string
	if t := tmpl.Lookup(objKind); t != nil {
		kindTemplateName = objKind
	} else {
		kindTemplateName = "DefaultResource"
	}
	return kindTemplateName
}

func unstructuredToRuntimeObject(obj map[string]interface{}) *unstructured.Unstructured {
	return &unstructured.Unstructured{Object: obj}
}

func runtimeObjectToSpecificObject(obj runtime.Object, out interface{}) error {
	return scheme.Scheme.Convert(obj, out, nil)
}

func includeEvents(obj runtime.Object, clientSet *kubernetes.Clientset, out map[string]interface{}) error {
	objectMeta := obj.(metav1.Object)
	events, err := clientSet.CoreV1().Events(objectMeta.GetNamespace()).Search(scheme.Scheme, obj)
	if err != nil {
		return errors.WithMessage(err, "Failed getting event")
	}
	eventsKey, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&events)
	if err != nil {
		return errors.WithMessage(err, "Failed getting JSON for Events")
	}
	out["events"] = eventsKey
	return nil
}

func includeNodeMetrics(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	// mind that metrics-server is reporting the workingSetSize rather than RSS,
	// see: https://github.com/kubernetes-sigs/metrics-server/issues/187
	config, _ := f.ToRESTConfig()
	clientSet, err := metricsv.NewForConfig(config)
	if err != nil {
		return errors.WithMessage(err, "Failed getting metrics clientSet")
	}
	objectMeta := obj.(metav1.Object)
	nodeMetrics, err := clientSet.MetricsV1beta1().
		NodeMetricses().
		Get(context.TODO(), objectMeta.GetName(), metav1.GetOptions{})
	if err != nil {
		// swallow any errors while getting NodeMetrics
		return nil
	}
	nodeMetricsKey, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&nodeMetrics)
	if err != nil {
		return errors.WithMessage(err, "Failed getting JSON for NodeMetrics")
	}
	out["nodeMetrics"] = nodeMetricsKey
	return nil
}

func includePodMetrics(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	config, _ := f.ToRESTConfig()
	clientSet, err := metricsv.NewForConfig(config)
	if err != nil {
		return errors.WithMessage(err, "Failed getting metrics clientSet")
	}
	objectMeta := obj.(metav1.Object)
	podMetrics, err := clientSet.MetricsV1beta1().
		PodMetricses(objectMeta.GetNamespace()).
		Get(context.TODO(), objectMeta.GetName(), metav1.GetOptions{})
	if err != nil {
		// swallow any errors while getting PodMetrics
		return nil
	}
	podMetricsKey, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&podMetrics)
	if err != nil {
		return errors.WithMessage(err, "Failed getting JSON for PodMetrics")
	}
	out["podMetrics"] = podMetricsKey
	return nil
}

func includeEndpoint(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	clientSet, _ := f.KubernetesClientSet()
	objectMeta := obj.(metav1.Object)
	endpoint, err := clientSet.CoreV1().
		Endpoints(objectMeta.GetNamespace()).
		Get(context.TODO(), objectMeta.GetName(), metav1.GetOptions{})
	if err != nil {
		return errors.WithMessage(err, "Failed getting Endpoint")
	}
	endpointKey, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&endpoint)
	if err != nil {
		return errors.WithMessage(err, "Failed getting JSON for Endpoint")
	}
	out["endpoint"] = endpointKey
	return nil
}

func includeNodeLease(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	clientSet, _ := f.KubernetesClientSet()
	objectMeta := obj.(metav1.Object)
	lease, err := clientSet.CoordinationV1().
		Leases(corev1.NamespaceNodeLease).
		Get(context.TODO(), objectMeta.GetName(), metav1.GetOptions{})
	if err != nil {
		return errors.WithMessage(err, "Failed getting Node Lease")
	}
	leaseKey, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&lease)
	if err != nil {
		return errors.WithMessage(err, "Failed getting JSON for Lease")
	}
	out["lease"] = leaseKey
	return nil
}

func includePodDetailsOnNode(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	clientSet, _ := f.KubernetesClientSet()
	objectMeta := obj.(metav1.Object)
	fieldSelector, err := fields.ParseSelector("spec.nodeName=" + objectMeta.GetName() +
		",status.phase!=" + string(corev1.PodSucceeded) +
		",status.phase!=" + string(corev1.PodFailed))
	if err != nil {
		return errors.WithMessage(err, "Failed creating fieldSelector for non-terminated Pods on Node")
	}
	nodeNonTerminatedPodsList, err := clientSet.CoreV1().
		Pods(objectMeta.GetNamespace()).
		List(context.TODO(), metav1.ListOptions{FieldSelector: fieldSelector.String()})
	if err != nil {
		return errors.WithMessage(err, "Failed getting non-terminated Pods for Node")
	}
	var podsList []interface{}
	for _, pod := range nodeNonTerminatedPodsList.Items {
		pod.Kind = "Pod"
		podKey, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(&pod)
		err = includePodMetrics(unstructuredToRuntimeObject(podKey), f, podKey)
		if err != nil {
			return errors.WithMessage(err, "Failed including PodMetrics for Pods for Node")
		}
		podsList = append(podsList, podKey)
	}
	out["pods"] = podsList
	return nil
}

func includeNodeStatsSummary(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	// This endpoint will be disabled soon https://github.com/kubernetes/kubernetes/issues/68522
	clientSet, _ := f.KubernetesClientSet()
	objectMeta := obj.(metav1.Object)
	getBytes, err := clientSet.CoreV1().RESTClient().Get().
		Resource("nodes").
		SubResource("proxy").
		Name(objectMeta.GetName()).
		Suffix("stats/summary").
		DoRaw(context.TODO())
	if err != nil {
		// ignore any errors querying the endpoint
		return nil
	}
	nodeStatsSummary := make(map[string]interface{})
	err = json.Unmarshal(getBytes, &nodeStatsSummary)
	if err != nil {
		return errors.WithMessage(err, "Failed parsing JSON for Node's /stats/summary")
	}
	out["nodeStatsSummary"] = nodeStatsSummary
	return nil
}

func includeIngressServices(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	clientSet, _ := f.KubernetesClientSet()
	ing := &v1beta1.Ingress{}
	err := scheme.Scheme.Convert(obj, ing, nil)
	if err != nil {
		return err
	}
	var backendIssues []IngressBackendIssue
	for _, rule := range ing.Spec.Rules {
	PATH:
		for _, path := range rule.HTTP.Paths {
			backend := path.Backend
			svcName := backend.ServiceName
			svcPort := backend.ServicePort
			for _, issue := range backendIssues {
				if issue.Backend.ServiceName == svcName &&
					issue.Backend.ServicePort == svcPort {
					continue PATH
				}
			}
			svc, err := clientSet.CoreV1().Services(ing.Namespace).Get(context.TODO(), svcName, metav1.GetOptions{})
			if (err != nil) || (svc.Name == "") {
				backendIssues = append(backendIssues, IngressBackendIssue{"serviceMissing", backend})
				continue PATH
			}
			portExist := false
			for _, port := range svc.Spec.Ports {
				if (svcPort.IntVal == port.Port) || (svcPort.StrVal == port.Name) {
					portExist = true
				}
			}
			if !portExist {
				backendIssues = append(backendIssues, IngressBackendIssue{"serviceWithPortMismatch", backend})
				continue PATH
			}
			endpoint, err := clientSet.CoreV1().Endpoints(ing.Namespace).Get(context.TODO(), svcName, metav1.GetOptions{})
			if (err != nil) || (endpoint.Name == "") || (len(endpoint.Subsets) == 0) {
				backendIssues = append(backendIssues, IngressBackendIssue{"serviceWithNoReadyAddresses", backend})
				continue PATH
			}
			for _, subset := range endpoint.Subsets {
				if len(subset.Addresses) == 0 {
					backendIssues = append(backendIssues, IngressBackendIssue{"serviceWithNoReadyAddresses", backend})
					continue PATH
				}
			}
		}
	}
	out["backendIssues"] = backendIssues
	return nil
}

func includeStatefulSetDiff(obj runtime.Object, f cmdutil.Factory, out map[string]interface{}) error {
	sts := &v1.StatefulSet{}
	err := runtimeObjectToSpecificObject(obj, sts)
	if err != nil {
		return errors.WithMessage(err, "StatefulSet object conversion failed")
	}

	if sts.Status.UpdateRevision != "" && sts.Status.CurrentRevision == sts.Status.UpdateRevision {
		// revision details are needed only when they differ
		return nil
	}

	config, _ := f.ToRESTConfig()
	clientSet, err := appsv1.NewForConfig(config)
	if err != nil {
		return errors.WithMessage(err, "Failed getting apps/v1 client")
	}

	currentRevision, err := clientSet.ControllerRevisions(sts.GetNamespace()).
		Get(context.TODO(), sts.Status.CurrentRevision, metav1.GetOptions{})
	if err != nil {
		return err
	}
	currentBytes, err := json.MarshalIndent(currentRevision.Data, "", "  ")
	if err != nil {
		return err
	}

	updateRevision, err := clientSet.ControllerRevisions(sts.GetNamespace()).
		Get(context.TODO(), sts.Status.UpdateRevision, metav1.GetOptions{})
	if err != nil {
		return err
	}
	updateBytes, err := json.MarshalIndent(updateRevision.Data, "", "  ")
	if err != nil {
		return err
	}
	currentTime := currentRevision.ObjectMeta.GetCreationTimestamp().Time
	updateTime := updateRevision.ObjectMeta.GetCreationTimestamp().Time

	diff := difflib.UnifiedDiff{
		A:        difflib.SplitLines(string(currentBytes)),
		B:        difflib.SplitLines(string(updateBytes)),
		FromFile: fmt.Sprintf("currentRevision ControllerRevision/%s", sts.Status.CurrentRevision),
		FromDate: fmt.Sprintf("%s (%s ago)", currentTime.String(), ago(currentTime)),
		ToFile:   fmt.Sprintf("updateRevision  ControllerRevision/%s", sts.Status.UpdateRevision),
		ToDate:   fmt.Sprintf("%s (%s ago)", updateTime.String(), ago(updateTime)),
		Context:  3,
	}
	diffString, _ := difflib.GetUnifiedDiffString(diff)

	out["diff"] = diffString

	return nil
}

func getTemplate() (string, error) {
	statikFS, err := sfs.New()
	if err != nil {
		return "", errors.WithMessage(err, "Failed initiating statikFS")
	}

	// Access individual files by their paths.
	templatesFile := "/templates.tmpl"
	t, err := statikFS.Open(templatesFile)
	if err != nil {
		return "", errors.WithMessage(err, "Failed opening template from statikFS")
	}
	defer t.Close()

	contents, err := ioutil.ReadAll(t)
	if err != nil {
		return "", errors.WithMessage(err, "Failed reading template from statikFS")
	}
	return string(contents), nil
}
